#include <iostream>
#include <ctime>
#include <cstdlib>
#include <math.h>
#include <cmath>
#include <string>
#include <sstream>
#include "fraction.h"

using namespace std;

#define ARRSIZE 5
enum Suit { clubs, diamonds, hearts, spades }; // от 2 до 10 обычные числа
const int jack = 11;
const int queen = 12;
const int king = 13;
const int ace = 14;

int maxInt(int a[], int size)
{
    int max = a[0];
    int indexNaib = 0;
    for (register int i = 0; i < ARRSIZE; i++)
    {
        if (max < a[i])
        {
            max = a[i];
            indexNaib = i;
        }
    }
    return indexNaib;
}
class card
{
private:
    int number;
    Suit suit;
public:
    card() {}// конструктор
    void set(int n, Suit s) { suit = s; number = n; } // установка значения
    void display() // вывод карты
    {
        if (number >= 2 && number <= 10)
            cout << number;
        else
        {
            switch (number)
            {
            case jack: cout << 'J'; break;
            case queen: cout << 'Q'; break;
            case king: cout << 'K'; break;
            case ace: cout << 'A'; break;
            }
        }
        switch (suit)
        {
        case clubs: cout << 'c'; break;
        case diamonds: cout << 'd'; break;
        case hearts: cout << 'h'; break;
        case spades: cout << 's'; break;
        }
    }
};
class safeArray
{
    int arr[ARRSIZE];
public:
    void SetElem(int index, int value)
    {
        if (index >= 0 && index <= ARRSIZE - 1)
            arr[index] = value;
        else
            cout << "Выход за границы массива!!!" << endl;
    }
    int GetElem(int index)
    {
        if (index >= 0 && index <= ARRSIZE - 1)
            return arr[index];
    }
};
class queue
{
    enum { MAX = 2 };
    int arr[MAX];
    int head, tail;
public:
    queue() { head = 0; tail = 0; } // конструктор
    void Set(int value)
    {
        if (tail == (head + 1) % MAX)
        {
            cout << "Очередь заполнена" << endl;
            return;
        }
        arr[head] = value;
        head = ++head % MAX;
        cout << "Записан элемент " << value << endl;
    }
    void Get()
    {
        if (head == tail)
        {
            cout << "Очередь пуста" << endl;
            return;
        }
        int result = arr[tail];
        tail = ++tail % MAX;
        cout << "Из очереди взято число : " << result << endl;
    }
};
class matrix
{
    int index1, index2;
    int arr[10][10];
public:
    matrix(int ind1, int ind2)
    {
        index1 = ind1;
        index2 = ind2;
    }
    void SetElem(int in1, int in2, int value)
    {
        if (in1 >= 0 && in1 < index1 && in2 >= 0 && in2 < index2)
            arr[in1][in2] = value;
        else
            cout << "Выход за границы массива!!!" << endl;
    }
    void GetElem(int in1, int in2)
    {
        if (in1 >= 0 && in1 < index1 && in2 >= 0 && in2 < index2)
            cout << arr[in1][in2];
    }
};
class money
{
public:
    long double mstold(string summa)
    {
        string res = "";
        for (register int i = 0; i < summa.length(); i++)
        {
            if (isdigit(summa[i]) | summa[i] == ',')
                res += summa[i];
        }
        return stold(res);
    }
    string ldtoms(long double sum)
    {
        if (sum > 9999999999999990.00) return "";
        ostringstream strs;
        strs << fixed << sum;
        string ustr = strs.str();
        string newstr = "$";

        int i;	int j;
        for (i = 0; i < ustr.length() && (ustr[i] == '0' || ustr[i] == '.'); i++); // считает "лишние" нули перед запятой И точку, если она идет СРАЗУ после нулей (например, $000456.23 -> i = 3 или 0,95 -> i = 2) 

        if (i > 1 && ustr[i - 1] == '.') i -= 2;

        if (i == ustr.length()) return "$0,00"; //Если количество "лишних" нулей вместе с точкой = длине строки, то вывод суммы "$0,00"

        for (j = ustr.length() - 1; j >= 0 && ustr[j] != '.'; j--); // кол-во знаков в числе БЕЗ запятой

        j += 2;

        for (; i <= j; i++)
        {
            if (i != 0 && i < j - 2 && (j - i + 1) % 3 == 0) //деление на три разряда
                newstr += '.';

            if (ustr[i] == '.')
                newstr += ',';
            else
                newstr += ustr[i];
        }
        return newstr;
    }
};
class bMoney : money {
    long double denstr;
public:
    void Setmoney(string mon) { denstr = mstold(mon); }
    void madd(bMoney s1, bMoney s2) { denstr = s1.denstr + s2.denstr; }
    void Getmoney() { cout << "Сумма равна " << ldtoms(denstr); }
};

int main()
{
    setlocale(LC_ALL, "rus");
    //4
    /*  Начните с программы, которая позволяет пользователю вводить целые числа, а затем сохранять их в массиве типа int.
        Напишите функцию maxint(), которая, обрабатывая элементы массива один за другим, находит наибольший.
        Функция должна принимать в качестве аргумента адрес массива и количество элементов в нем, а возвращать индекс наибольшего элемента.
        Программа должна вызвать эту функцию, а затем вывести наибольший элемент и его индекс.  */
    int arr[ARRSIZE];
    cout << "Заполните массив " << ARRSIZE << " элементами" << endl;
    for (register int i = 0; i < ARRSIZE; i++)
    {
        cout << "a[" << i << "] = ";
        cin >> arr[i];
    }
    cout << "Наибольшее число имеет индекс: " << maxInt(arr, ARRSIZE) << endl << endl;

    //5
    /*  Начните с класса fraction из упражнений 11 и 12 лабораторной работы 5.
        Напишите функцию main(), которая получает случайные дробные числа от пользователя, сохраняет их в массиве типа fraction, вычисляет среднее значение и выводит результат.    */
    fraction drobArr[ARRSIZE];
    fraction drobItog[1];
    cout << "Введите дроби" << endl;
    for (register int i = 0; i < ARRSIZE; i++)
    {
        drobArr[i].setDrob();
        drobArr[i].srredSumm(drobItog[0], drobArr[i]);
    }
    drobItog[0].umnozhNaCheloe(drobItog[0], ARRSIZE);
    drobItog[0].sokrashDrobi(drobItog[0]);
    drobItog[0].GetDrob();

    //6
    /*  В игре бридж каждому из игроков раздают 13 карт, таким образом колода расходуется полностью.
        Модифицируйте программу CARDARAY этой главы так, чтобы после перемешивания колоды она делилась на четыре части по 13 карт каждая.
        Каждая из четырех групп карт затем должна быть выведена.    */
    card deck[52];
    int j;
    cout << endl;
    for (j = 0; j < 52; j++) // создаем упорядоченную колоду карт
    {
        int num = (j % 13) + 2;
        Suit su = Suit(j / 13);
        deck[j].set(num, su);
    }
    cout << "Исходная колода:\n";
    for (j = 0; j < 52; j++)
    {
        deck[j].display();
        cout << " ";
        if (!((j + 1) % 13)) // начинаем новую строку после каждой 13-й карты
            cout << endl;
    }
    srand(time(NULL)); // инициализируем генератор случайных чисел
    for (j = 0; j < 52; j++)
    {
        int k = rand() % 52; // выбираем случайную карту
        card temp = deck[j]; // и меняем ее с текущей
        deck[j] = deck[k];
        deck[k] = temp;
    }
    card newHand[4][13];

    for (int i = 0, j = 0; j < 52; j++)
    {
        int buf = (j + 1) % 13;
        newHand[i][buf] = deck[j];
        if (!buf) i++;
    }
    cout << "\nПеремешанная колода:\n";
    for (int i = 0; i < 4; i++)
    {
        cout << "Колода №" << (i + 1) << ":\n";
        for (card kar : newHand[i])
        {
            kar.display();
            cout << ' ';
        }
        cout << endl;
    }

    //7
    /*  Одним из недостатков C++ является отсутствие для бизнес-программ встроенного типа для денежных значений, такого, как $173 698 001,32.
        Такой денежный тип должен иметь возможность для хранения числа с фиксированной десятичной точкой точностью около 17 знаков, которого было бы достаточно для хранения национального долга в долларах и центах.
        К счастью, встроенный тип C++ long double имеет точность 19 цифр, поэтому мы можем использовать его как базисный для класса money, даже используя плавающую точку.

        Однако нам нужно будет добавить возможность ввода и вывода денежных значений с предшествующим им знаком доллара и разделенными запятыми группы по три числа: так проще читать большие числа.
        Первым делом при разработке такого класса напишем метод mstold(), который принимает денежную строку, то есть строку, представляющую собой некоторое количество денег типа
        “$123.456.789.00” в качестве аргумента и возвращает эквивалентное ее значению число типа long double.

        Вам нужно будет обработать денежную строку как массив символов и, просматривая ее символ за символом, скопировать из нее только цифры (0-9) и десятичную точку в другую строку.
        Игнорируется все остальное, включая знак доллара и запятые.

        Затем вы можете использовать библиотечную функцию _atold() для преобразования новой строки к числу типа long double.
        Предполагаем, что денежное значение не может быть отрицательным.

        Напишите функцию main() для проверки метода mstold(), которая несколько раз получает денежную строку от пользователя и выводит соответствующее число типа long double.    */
    char prodolzhenie = 'y';
    while (prodolzhenie == 'y')
    {
        string summa;
        money a;
        cout << "\nВведите сумму, отделив центы запятой: $" && cin >> summa;
        cout << a.mstold(summa);
        cout << "\nПродолжить ввод? (введите 'y' если согласны или любой другой символ, дабы отказаться) ";
        cin >> prodolzhenie;
    }

    //8
    /* Другим недостатком C++ является отсутствие автоматической проверки индексов массива на соответствие их границам массива (это делает действия с массивами быстрыми, но менее надежными).
        Мы можем использовать класс для создания надежного массива, который проверяет индексы при любой попытке доступа к массиву.

        Напишите класс safearay, который использует массив типа int фиксированного размера (назовем его LIMIT) в качестве своей единственной переменной. В классе будет два метода:

        Первый, putel(), принимает индекс и значение типа int как аргументы и вставляет это значение в массив по заданному индексу.
        Второй, getel(), принимает индекс как аргумент и возвращает значение типа int, содержащееся в элементе с этим индексом.

        safearay sal:	//	описываем массив
        int temp = 12345:	//	описываем целое
        sal.putel (7, temp );	//	помещаем значение	temp в массив
        temp = sal.getel(7.4)://	получаем значение из массива

        Оба метода должны проверять индекс аргумента, чтобы быть уверенными, что он не меньше 0 и не больше, чем LIMIT—1.
        Вы можете использовать этот массив без опаски, что запись будет произведена в другие части памяти.
        Использование методов для доступа к элементам массива не выглядит так наглядно, как использование операции [ ].	*/
    safeArray a;
    int ind, val;
    cout << "\nВведите ячейку (массив состоит из " << ARRSIZE << " эл.) и число, которое необходимо туда записать: " && cin >> ind >> val;
    a.SetElem(ind, val);
    cout << a.GetElem(ind) << endl << endl;

    //9
    /*	Очередь — это устройство для хранения данных, похожее на стек.
        Отличие в том, что в стеке последний сохраненный элемент будет первым извлеченным, тогда как в очереди первый сохраненный элемент будет первым извлеченным.

        То есть в стеке используется подход «последний вошел — первый вышел» (LJFO),а в очереди используется подход «первый вошел — первый вышел» (FIFO).
        Очередь похожа на простую очередь посетителей магазина: первый, кто встал в очередь, будет обслужен первым.

        Перепишите программу STAKARAY из этой главы, включив в нее класс queue вместо класса stack. Кроме того, класс должен иметь два метода: один, называемый put(), для помещения элемента в очередь;
        и другой, называемый get(), для извлечения элемента из очереди. Эти методы эквивалентны методам push() и рор() класса stack.

        Оба класса, stack и queue, используют массив для хранения данных. Однако вместо одного поля top типа int, как в классе stack,
        вам понадобятся два поля для очереди: одна, называемая head, указывающая на начало очереди; и вторая, tail, указывающая на конец очереди.

        Элементы помещаются в конец очереди (как посетители банка, становящиеся в очередь), а извлекаются из начала очереди.
        Конец очереди перемещается к началу по массиву по мере того, как элементы добавляются и извлекаются из очереди.

        Такие результаты добавляют сложности: если одна из двух переменных head или tail примут значение конца массива, то следует вернуться на начало.
        Таким образом, вам нужно выражение типа
        if ( tail == MAX - 1 ) { tail = -1 };
        для возврата переменной tail и похожее выражение для возврата переменной head.
        Массив, используемый в очереди, иногда называют круговым буфером, так как начало и конец очереди циркулируют по нему вместе с ее данными.	*/
    queue q;
    q.Set(5); q.Set(4);
    q.Get();  q.Get();

    //10
    /*	Матрица — это двумерный массив. Создайте класс matrix, который предоставляет те же меры безопасности, как и класс из задания 7,
        то есть осуществляет проверку индексов массива на вхождение их в границы массива.

        Полем класса matrix будет массив 10 на 10. Конструктор должен позволять программисту определить реальный размер массива (допустим, сделать его меньше, чем 10 на 10).
        Методам, предназначенным для доступа к членам матрицы, теперь нужны два индекса: по одному для каждой размерности массива.

        Вот фрагмент функции main(), которая работает с таким классом:
        matrix ml(3,4); // Описываем матрицу
        int temp = 12345; // Описываем целое
        ml.putel(4, 4, temp); // Помещаем значение
        temp = ml.getel(7,4); // Получаем значение из матрицы	*/
    int i1 = -1, i2 = -1;
    int value;

    while (i1 < 0 || i1 > 10 && i2 < 0 || i2 >10)
        cout << "\nОбозначьте размерность массива, меньшую или равную, чем 10х10 (x y): " && cin >> i1 >> i2;

    matrix mat(i1, i2);
    cout << "В какую ячейку записать число (x y): " && cin >> i1 >> i2;
    cout << "Запишите число в ячейку массива -> " && cin >> value;
    mat.SetElem(i1, i1, value);
    mat.GetElem(i1, i2);

    //11
    /*	Вернемся к обсуждению денежных строк из упражнения 7. Напишите метод ldtoms() для преобразования числа типа long double в денежную строку, представляющую это число.
        Для начала вам нужно проверить, что значение long double не очень большое. Мы предполагаем, что вы не будете пытаться преобразовать число, больше чем 9 999 999 999 999 990.00.

        Затем преобразуем long double в строку (без знака доллара и запятых), хранящуюся в памяти, используя объект ostringstream, как рассматривалось ранее в этой главе.
        Получившаяся отформатированная строка может быть помещена в буфер, называющийся ustring.

        Затем вам нужно будет создать другую строку, начинающуюся со знака доллара, далее копируем цифру за цифрой из строки ustring, начиная слева и вставляя запятые через каждые три цифры.
        Также вам нужно подавлять нули в начале строки. Например, вы должны вывести $3 124.95, а не $0 000 000 000 003 124.95. Не забудьте закончить строку нулевым символом '\0'.

        Напишите функцию main() для тестирования этой функции путем многократного ввода пользователем чисел типа long double и вывода результата в виде денежной строки.	*/
    do
    {
        money m;
        long double s;
        cout << "\n\nВведите long double: " && cin >> s;
        cout << "Денежная сумма: " << m.ldtoms(s) << endl;
        cout << "Продолжить(y/n)? " && cin >> prodolzhenie;
    } while (prodolzhenie == 'y');

    //12
    /*  Создайте класс bMoney. Он должен хранить денежные значения как long double.
        Используйте метод mstold() для преобразования денежной строки, введенной пользователем, в long double, и метод ldtoms() для преобразования числа типа long double в денежную строку для вывода (задания 6 и 10).
        Вы можете вызывать для ввода и вывода методы getmoney()и putmoney().
        Напишите другой метод класса для сложения двух объектов типа ЬМопеу и назовите его madd().
        Сложение этих объектов легко произвести: просто сложите переменную типа long double одного объекта с такой же переменной другого объекта.
        Напишите функцию main(), которая просит пользователя несколько раз ввести денежную строку, а затем выводит сумму значений этих строк. */
    do
    {
        bMoney s1, s2, svrem;
        string denstroka;
        cout << "\nВведите первую денежную строку (точки разделяют разряды числа, а запятые в водимом числе - центы от долларов): " && cin >> denstroka;
        s1.Setmoney(denstroka);
        cout << "Введите вторую денежную строку: " && cin >> denstroka;
        s2.Setmoney(denstroka);
        svrem.madd(s1, s2);
        svrem.Getmoney();
        cout << "\nПродолжить(y/n)? " && cin >> prodolzhenie;
    } while (prodolzhenie == 'y');
}